<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>homepage_share_doc</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h1 id="toc_0">小米直播iOS客户端首页架构与优化</h1>

<h6 id="toc_1">Dylan Lai 2017.04.20</h6>

<hr>

<h3 id="toc_2">核心内容</h3>

<ul>
<li>首页TableView基于MVVM的改造和实现。</li>
<li>如何保持界面流畅度。</li>
</ul>

<h2 id="toc_3"></h2>

<h3 id="toc_4">首页需求简述</h3>

<ul>
<li>运营同学在后台配置，通过模板间自由组合，能够快速地组装一个直播列表。</li>
<li><strong>模板样式一直在改变</strong>：在多次版本迭代的过程中，产品、设计同学已经针对同一个模板的样式多次修改。</li>
<li><strong>模板数量一直在增长</strong>：首页从项目起步时3种样式（大图、3*n、广告横条），一直在扩充从未停止，截至目前，首页已定义的模板数量已达35个，模板定义<a href="http://wiki.n.miui.com/pages/viewpage.action?pageId=25049393">传送门</a>。</li>
</ul>

<blockquote>
<p>一句话总结，首页一直在做 “增”、“改” 操作。</p>
</blockquote>

<h2 id="toc_5"></h2>

<h3 id="toc_6">多样化TableViewCell的最基本实现</h3>

<div><pre><code class="language-none">
#pragma mark - UITableViewDelegate

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    TempleteEnum style = dataSource.item[index].style;
    if (style == Templet1) {
        return 44;
    } else if (style == Templet2) {
        return [self calcHeightWithTemplte:dataSource.item[index]];
    ...
}

#pragma mark - UITableViewDataSource

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    TempleteEnum style = dataSource.item[index].style;
    if (dataSource.item[index].style == Templet1) {
        static NSString *cellId = @&quot;Templet1Cell&quot;;
        Templet1Cell *cell = [tableView dequeueReusableCellWithIdentifier:cellId];
        if (cell == nil) {
            cell = [[Templet1Cell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];
        }
        [cell updateWithDataSource:];
        return cell;
    } else if (dataSource.item[index].style == Templet2) {
        static NSString *cellId = @&quot;Templet2Cell&quot;;
        Templet2Cell *cell = [tableView dequeueReusableCellWithIdentifier:cellId];
        if (cell == nil) {
            cell = [[Templet2Cell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];
        }
        [cell updateWithDataSource:];
        return cell;
    }   
    ...
}
</code></pre></div>

<blockquote>
<p>根据设计模式的 OCP (Open-Close Principle), 上面的代码是不允许，绝对不允许。</p>
</blockquote>

<h5 id="toc_7">这样写代码潜在的问题</h5>

<ul>
<li>controller(实现UITableViewDelegate, UITableViewDataSource的地方)太臃肿,随着模板数量的增多，一个文件里（甚至是一个方法里）代码行数非常多。</li>
<li>增加模板需要修改controller（源于大量的if-else语句）</li>
</ul>

<h2 id="toc_8"></h2>

<h3 id="toc_9">基于MVVM设计的tableView</h3>

<h4 id="toc_10">What diff between MVC and MVVM?</h4>

<ul>
<li>MVC - (Model-View-Controller)</li>
<li>MVVM - (Model-View-ViewModel)</li>
</ul>

<p><img src="https://objccn.io/images/issues/issue-13/mvvm1.png" alt=""></p>

<blockquote>
<p>MVC示意图(1)</p>
</blockquote>

<p><img src="https://objccn.io/images/issues//issue-13/intermediate.png" alt=""></p>

<blockquote>
<p>MVC示意图(2) </p>
</blockquote>

<p><img src="https://objccn.io/images/issues//issue-13/mvvm.png" alt=""></p>

<blockquote>
<p>MVVM示意图</p>
</blockquote>

<p>MVVM解决的问题是MVC中C-Controller过分臃肿的问题，View控制代码拆分出来，生成在各自的VM-ViewModel，而不是集中在Controller一处。</p>

<h6 id="toc_11">Referance：</h6>

<ul>
<li>MVVM介绍 <a href="https://objccn.io/issue-13-1/">https://objccn.io/issue-13-1/</a></li>
<li>MVC，MVP 和 MVVM 的图示 <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></li>
</ul>

<h4 id="toc_12">ActiveTableView Architecture</h4>

<h5 id="toc_13">ActiveTableViewController</h5>

<p>对tableView封装，并在内部实现(UITableViewDelegate，UITableViewDataSource)，user不再需要关心tableView的各种Delegate，只关心ViewModel本身的增删改操作，而且ActiveTableViewController只对ViewModel关心，ViewModel提供足够的接口来支持tableView工作。</p>

<div><pre><code class="language-none">@interface ActiveTableController : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;

@property (nonatomic,readonly) UITableView *tableView;

- (void)insertOrUpdateWithModel:(NSArray&lt;id&lt;ActiveModelProtocol&gt;&gt; *)modelArray;
//...省略其他增删改Model的接口

- (NSArray&lt;id&lt;ActiveModelProtocol&gt;&gt; *)allModels;
- (NSUInteger)numberOfModels;

@end</code></pre></div>

<h4 id="toc_14">ActiveModelProtocol</h4>

<p>上文说了，ViewModel提供足够的接口来支持tableView的工作。</p>

<div><pre><code class="language-none">@class ActiveTableViewCell;
@protocol  ActiveModelProtocol &lt;NSObject&gt;

@required
- (CGFloat)displayHeightForTableView:(UITableView *)tableView;          （1）
- (ActiveTableViewCell *)cellForTableView:(UITableView *)tableView;     （2）
//...篇幅所限省略其他方法

@end</code></pre></div>

<ul>
<li>方法1 对标支持 <code>tableView:heightForRowAtIndexPath:</code></li>
<li>方法2 对标支持 <code>cellForRowAtIndexPath:</code></li>
</ul>

<h3 id="toc_15">ActiveTableCell</h3>

<div><pre><code class="language-none">@interface ActiveTableViewCell : UITableViewCell

@property(nonatomic,strong)id&lt;ActiveModelProtocol&gt; viewModel;

@end</code></pre></div>

<p>再次看一下这图，view持有viewModel
<img src="https://objccn.io/images/issues//issue-13/mvvm.png" alt=""></p>

<blockquote>
<p>MVVM示意图</p>
</blockquote>

<h4 id="toc_16">Advantage &amp; Disadvantage</h4>

<h5 id="toc_17">优势</h5>

<ul>
<li>耦合性低，遵循OCP，增加模板不需改动核心代码，只需新创建代码文件即可；改动某个模板，不影响其他模板的使用，各个模板业务逻辑代码实现了物理隔离。</li>
</ul>

<h5 id="toc_18">局限性</h5>

<ul>
<li>目前只支持一维数据源，不支持原生tableView的Section概念。</li>
<li>需要在原生tableView原理基础上理解ActiveTableView设计理念，有学习成本。</li>
</ul>

<blockquote>
<p><strong>在直播项目中，首页直播列表、搜索列表、私信对话列表tableView都采用ActiveTableView的架构设计。</strong></p>
</blockquote>

<h2 id="toc_19"></h2>

<h3 id="toc_20">首页优化</h3>

<blockquote>
<p><strong>在3.0版本，首页最大的问题，滑动太<sup>TM</sup>卡了</strong></p>
</blockquote>

<h4 id="toc_21">寻找影响界面流畅度的关键路径</h4>

<blockquote>
<p>使用Instrument调优</p>

<h6 id="toc_22">Referance：<a href="http://www.samirchen.com/use-instruments/">http://www.samirchen.com/use-instruments/</a></h6>
</blockquote>

<p>众所周知，耗时的操作，必须放在background thread运行，放在了主线程就必然影响界面的流畅度。以下列举首页列表的耗时操作</p>

<table>
<thead>
<tr>
<th>Item</th>
<th>Run in Background Thread</th>
</tr>
</thead>

<tbody>
<tr>
<td>layout constraints <code>install</code> <code>update</code> <code>uninstall</code></td>
<td>No</td>
</tr>
<tr>
<td>attributed string 设置(赋值)</td>
<td>No</td>
</tr>
<tr>
<td>频繁调用<code>addSubview:</code> <code>removeFromSuperView</code></td>
<td>No</td>
</tr>
<tr>
<td>文本高度计算 <code>NSString boundingRectWithSize:options:attributes:context:</code></td>
<td>Yes</td>
</tr>
<tr>
<td>attributed string 创建</td>
<td>Yes</td>
</tr>
<tr>
<td>基于frame的布局重置 <code>UIView sizeTofit</code></td>
<td>-</td>
</tr>
<tr>
<td>图片加载</td>
<td>-</td>
</tr>
</tbody>
</table>

<h5 id="toc_23">AutoLayout, 开发速度与用户体验之间的较量</h5>

<p>autolayout的出现，极大了提高了我们对UI的开发效率，尤其是引入<code>Masonry</code>后，简洁的布局语法，可读性，可维护性优于原生的VFL语法，大大促进了autolayout的使用。</p>

<p>在使用<em>Instrument-Time Profiler</em>的过程中, <code>layout constrains install/uninstall</code>占了main thread大量的运行时间，换言之，如何降低<code>layout constrains install/unstall</code>的调用成了首页优化的关键路径。</p>

<blockquote>
<p>必须注意的是，所有 layout constrains 的操作必须放在main thread，不能放在background thread。</p>
</blockquote>

<p>经过排查，发现首页模板在tableViewCell重用时，都会调用布局重置的代码:</p>

<div><pre><code class="language-none">- (void)setViewModel:(PRGeneralLiveCellModel *)viewModel {
    if (_viewModel == viewModel) {
        return;
    }
    
    _viewModel = viewModel;
    [self subviewsInitWithViewModel:viewModel];
    [self bindViewModel:viewModel];
    [self relayoutWithModel:viewModel];
}

- (void)relayoutWithModel:(PRGeneralLiveCellModel *)viewModel {
    CGFloat leftPadding = self.viewModel.edgePadding.left;
    CGFloat rightPadding = self.viewModel.edgePadding.right;
    CGFloat itemPadding = self.viewModel.itemPadding;
    NSUInteger maxItemCount = self.viewModel.maxItemCount;
    
    [self.assistanceView mas_remakeConstraints:^(MASConstraintMaker *make) {
        make.left.equalTo(self.contentView).offset(leftPadding + rightPadding + (maxItemCount - 1) * itemPadding);
        make.top.bottom.right.equalTo(self.contentView);
    }];
    
    UIView *lastView = nil;
    CGFloat itemLeftPaddingOffset = leftPadding;
    for (int i = 0 ; i &lt; maxItemCount ; i++) {
        XMTempletView *itemView = self.itemViewArray[i];
        // layout
        [itemView mas_remakeConstraints:^(MASConstraintMaker *make) {
            make.left.equalTo(lastView ? lastView.mas_right : itemView.superview.mas_left).offset(itemLeftPaddingOffset);
            make.width.equalTo(self.assistanceView).dividedBy(maxItemCount);
            make.top.equalTo(self.contentView).offset(viewModel.edgePadding.top);
            make.bottom.equalTo(self.contentView).offset(-viewModel.edgePadding.bottom);
        }];
        
        lastView = itemView;
        itemLeftPaddingOffset = itemPadding;
    }
}</code></pre></div>

<p>viewModel含有边距属性，为保证修改viewModel边距属性后，能修改UI边距，所以这里有<code>mas_remakeConstraints</code>代码。因为建立、更改约束是耗时操作，必须尽量地减少。所以在此次优化中，引入缓存机制，view把上一次边距等影响布局的属性缓存起来，待下次viewModel更新时，先于缓存中的边距比对，如没有变化，就无必要进行autolayout constrains remake。</p>

<blockquote>
<p>优化思路：&quot;用空间换时间&quot;</p>
</blockquote>

<p>就算缓存了边距，减少了大量不必要的布局约束更新，但初始化时，也必须建立约束。
先看一组图表，autolayout constrains执行效率。</p>

<p><img src="http://zbtupian.zb.mi.com/pic_e898a44fe00515dd69277973c9a31228_1492680433229.png" alt=""></p>

<p>上面这组图可以看出了，当View的个数越多，当view嵌套层数越多，autolayout操作耗时越大，而且嵌套会导致指数级上升。</p>

<p>向UIView开刀，减少页面中view的个数，减少view嵌套层级可以减低首次必须建立约束所带来的性能影响。</p>

<ul>
<li>用CALayer代替没有交互的行为的UIView</li>
<li>用UIGusture代替UIButton显示用户交互（如点击交互）</li>
</ul>

<p>向autoLayout嵌套层级开刀，在多层嵌套的view中，在某一层view用frame布局代替autolayout切断嵌套层级。（当然这个不好做）</p>

<blockquote>
<p>优化思路： 合理降低autolayout的使用频率</p>
</blockquote>

<h5 id="toc_24">合理使用地图片</h5>

<p>在使用instrument调优过程中，通过对autolayout的优化，界面的流畅度大大提升，这次轮到了image成为了瓶颈。</p>

<ul>
<li><p>能用小图的用小图显示</p>

<p>在项目初期，我们通过金山云的支持，对图片进行压缩处理，在图片URL后添加<code>@style@size</code>参数就可以很方便的获取合适尺寸的图片。我们对应封装了一个category: NSURL+ImageQuality.h</p>

<p>抓取实际图片可以看到一般首页用的直播间封面图 @style@480 约等于 40KB/张，@style@320 约等于20KB/张，n*3的样式，没有必要用@480,使用@320即可，同时可以减低用户的流量消耗，一举两得。</p></li>
<li><p>最大图片限制
当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。
各iOS设备屏幕参数：<a href="http://iosres.com">传送门</a></p></li>
<li><p><code>[UIImageView imageName:]</code>也是相对耗时，对于同一张图片，应采取一些手段来避免同一张图片（切图）重复赋值。</p></li>
<li><p>少用<code>[UIImage createImageWithColor:]</code>, 内部使用了CoreGraphics来画纯色图片，其中<code>UIGraphicsGetCurrentContext()</code>获取上下文是耗时操作，应尽量少用。若重复使用纯色图片，应把生成的图片缓存起来备用，而不是每用一次创建一次。</p></li>
</ul>

<h5 id="toc_25">图层的叠加</h5>

<h5 id="toc_26">严格控制圆角的使用</h5>

<h4 id="toc_27">进一步优化 - 使用AsyncDisplayKit</h4>

<blockquote>
<p>Reference: <a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>
</blockquote>

<h2 id="toc_28"></h2>

<h3 id="toc_29">总结</h3>

<p>经过上文提及的优化方案优化后，首页的流畅度大大提升，最明显是用iPhone5S来体验。优化前可以算是不可用的状态，优化后需仍有明显卡顿，但属于可接受范围。</p>

<p>用一句话概括首页优化的过程：</p>

<blockquote>
<p>善于使用Xcode工具,用Instrument TimeProfiler定位耗时代码，用空间（缓存）换时间。能放到后台线程执行的代码坚决不放在主线程执行。</p>
</blockquote>




</body>

</html>
